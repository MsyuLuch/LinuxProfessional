# **Домашнее задание №9**

## **Управление процессами**
 
Задания на выбор:

 - написать свою реализацию ps ax используя анализ /proc

Результат ДЗ - рабочий скрипт который можно запустить
 
# **Исходные данные**

Ссылка на проект https://github.com/MsyuLuch/LinuxProfessional/tree/main/homework-9

Здесь:
- `readme.md` - описание процесса выполнения домашнего задания
- `ps.sh` - скрипт, простой аналог команды `ps -aux` 

# **Описание процесса выполнения домашнего задания №9**

***Простой аналог команды ps -aux***

Получим список всех процессов, выполняющихся в системе (/proc — виртуальная файловая система):
```
pid_array=$(ls /proc | grep -E '^[0-9]+$' | sort -n)
```
Информация о каждом запущенном процессе содержится в файлах `/proc/[PID]/stat`, `/proc/[PID]/status`:
```
USER	Имя владельца процесса
RSS	    Размер резидентного набора (количество страниц памяти)
STAT	Текущий статус процесса:
        R — выполняется
        D — ожидает записи на диск
        S — неактивен (< 20 с)
        T — приостановлен
        Z — зомби
        Дополнительные флаги:
        W — процесс выгружен на диск
        < — процесс имеет повышенный приоритет
        N — процесс имеет пониженный приоритет
        L — некоторые страницы блокированы в оперативной памяти
        s — процесс является лидером сеанса
COMMAND	Имя и аргументы команды
```

Чтобы рассчитать загрузку процессора для конкретного процесса:

 - `/proc/uptime` - время безотказной работы системы (секунды)
 - `/proc/[PID]/stat` - 
    - [14] utime - Процессорное время, затраченное в пользовательском коде, измеряется в тактах
    - [15] stime - Процессорное время, затраченное в коде ядра, измеряется тактами часов
    - [16] cutime - Ожидаемое время процессора для детей, затраченное в пользовательском коде (в тактахчасов)
    - [17] cstime - Ожидание детского процессорного времени, затраченного в коде ядра (в тактахчасов)
    - [22] starttime - Время начала процесса, измеряемое тактами часов

- `getconf CLK_TCK` - количество тактов часов (`clock_ticks`).

Определяем общее время, затраченное на процесс:
```
total_time = utime + stime
```
Включаем в процессы время от детей:
```
total_time = total_time + cutime + cstime
```
Получаем общее время, прошедшее в секундах с момента начала процесса:
```
seconds = uptime - (starttime / clock_ticks)
```
Рассчитываем процент использования процессора:
```
cpu_usage = 100 * ((total_time / clock_ticks) / seconds)
```
Чтобы рассчитать количество памяти для конкретного процесса:
 - `/proc/meminfo` - информация об оперативной памяти

 - `/proc/[PID]/statm` - 
    - [2] resident - resident set size
    - [6] data_and_stack - data + stack
    
Рассчитываем процент использования памяти:
```
memory_usage = (resident + data_and_stack) * 100) / total_memory
```